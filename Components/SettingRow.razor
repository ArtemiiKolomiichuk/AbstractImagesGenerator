
<div class="setting-row">
    <div class="@(Inherited ? "setting-row-title inherited" : "setting-row-title")" style="padding-right:1em">
        @Setting.Title
    </div>
    @switch (Setting.VisibleType)
    {
        case PropertyDisplayType.Slider:
            {
                <input type="range" min="@(Setting.MinValue ?? 0)" max="@(Setting.MaxValue ?? 0)" 
                step="@(Setting.DataType == PropertyValueType.Float ? 0.01 : 1)" 
                value="@(Setting.Value switch {
                        FloatValue floatValue => floatValue.Value,
                        IntValue intValue => intValue.Value
                    })"
                @onchange ="(e) => 
                       { 
                            double val = double.Parse(e.Value.ToString());
                            Setting.Value = Setting.DataType switch
                            {
                                PropertyValueType.Float => new FloatValue(val),
                                PropertyValueType.Int => (int)val,
                                _ => throw new NotImplementedException()
                            };
                            StateHasChanged();
                            Update(); 
                       }"
                style="margin: 0.4rem; width: 6rem;" />
            }
            break;
        case PropertyDisplayType.RangeSlider:
            {
                <RangeSlider Min="@(Convert.ToDouble(Setting.MinValue ?? 0))" Max="@(Convert.ToDouble(Setting.MaxValue ?? 0))" 
                Step="@(Setting.DataType == PropertyValueType.FloatTuple ? 0.01 : 1)"
                MaxValue="Setting.Value switch{
                    FloatTupleValue floatTupleValue => floatTupleValue.Values.Item2,
                    IntTupleValue intTupleValue => intTupleValue.Values.Item2
                }"
                MinValue="Setting.Value switch{
                    FloatTupleValue floatTupleValue => floatTupleValue.Values.Item1,
                    IntTupleValue intTupleValue => intTupleValue.Values.Item1
                }"
                OnChange="(r) => {
                    (double, double) val = Setting.Value switch
                    {
                        FloatTupleValue floatTupleValue => (floatTupleValue.Values.Item1, floatTupleValue.Values.Item2),
                        IntTupleValue intTupleValue => (intTupleValue.Values.Item1, intTupleValue.Values.Item2)
                    };

                    if(r.Item1 == val.Item1 && r.Item2 == val.Item2)
                    {
                        return;
                    }

                    Setting.Value = Setting.DataType switch
                    {
                        PropertyValueType.FloatTuple => (r.Item1, r.Item2), 
                        PropertyValueType.IntTuple => ((int)r.Item1, (int)r.Item2),
                        _ => throw new NotImplementedException()
                    };
                    Update(); 
                }
                "/>
            }
            break;
        case PropertyDisplayType.Checkbox:
            {
                <input type="checkbox" checked="@(Setting.Value is BoolValue boolValue && boolValue.Value)" 
                @onchange="(e) => { Setting.Value = bool.Parse(e.Value?.ToString() ?? false.ToString()); Update(); }" />
            }
            break;
        case PropertyDisplayType.Dropdown:
            {
                <Selector Class="selector" Options="@([..Setting.PossibleValues!.Keys.Skip(1)])" Title="@Setting.PossibleValues.First().Key"
                OnSelect="(s) => {
                    if(string.IsNullOrWhiteSpace(s))
                    {
                        Setting.Value = Setting.PossibleValues.First().Value;
                        return;
                    }
                    Setting.Value = Setting.PossibleValues[s];
                }"/>
            }
            break;
        case PropertyDisplayType.Colors:
            {
                var list = Setting.Value as StringListValue;
                if(list == null)
                {
                    throw new InvalidOperationException("Setting value is not a StringListValue");
                }
                bool shrinkable = list.Values.Count > (Setting.MinCount ?? 0);
                bool expendable = list.Values.Count < Setting.MaxCount;
                <div style="display: flex;
                            align-items: center;
                            flex-wrap: wrap;">
                    @for(int l = 0; l < list.Values.Count; l++)
                    {
                        int i = l;
                        <div class="color-input-block">
                            <div class="color-value" 
                                 style="@($"background-color: {list.Values[i]?.ToString() ?? "black"};")"
                                 @onclick="async (e) => {
                                     var modal = AbstractImagesGenerator.Pages.Home.ColorModal;
                                     modal.SetColor(list.Values[i]);
                                     modal.SetCanDelete(shrinkable);
                                     await modal.Configure(e);
                                     modal.SetOnColorChanged((c) => {
                                         list.Values[i] = c;
                                         Setting.Value = list;
                                         StateHasChanged();
                                     });
                                     var (color, delete) = await modal.ShowAsync();
                                     if(delete)
                                     {
                                        list.Values.RemoveAt(i);
                                        Setting.Value = list;
                                        Update();
                                     }
                                     else if (color != null)
                                     {
                                        list.Values[i] = color;
                                        Setting.Value = list;
                                        Update();
                                     }
                                 }"
                            />
                        </div>
                    }
                    @if (expendable)
                    {
                        <span @onclick="() => { list.Values.Add(RandomColor()); Setting.Value = list; Update(); }" style="height: 2rem;-webkit-user-select: none;"  title="Add Color">
                            <Ico Class="icon-button pink" Icon="@Icons.Add" Size="2" />
                        </span>
                    }
                    <span @onclick="() => Setting.Value = RandomPalette(list.Values.Count).ToList()" style="height: 2rem;-webkit-user-select: none;" title="Randomize Colors">
                        <Ico Class="icon-button pink" Icon="@Icons.Shuffle" Size="2" />
                    </span>
                </div>
            }
            break;
    }
</div>

@code {
    [Parameter]
    public LayerSetting Setting { get; set; }

    [Parameter]
    public bool Inherited { get; set; }

    [Parameter]
    public Action Update { get; set; }

    private static string RandomColor()
    {
        var random = new Random();
        return $"#{random.Next(0x1000000):X6}";
    }

    private static string[] RandomPalette(int amount)
    {
        double HueToRGB(double p, double q, double t)
        {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1.0 / 6.0)
                return p + (q - p) * 6 * t;
            if (t < 1.0 / 2.0)
                return q;
            if (t < 2.0 / 3.0)
                return p + (q - p) * (2.0 / 3.0 - t) * 6;
            return p;
        }

        string HSLToHex(double h, double s, double l)
        {
            double r, g, b;
            if (s == 0)
            {
                r = g = b = l;
            }
            else
            {
                double q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                double p = 2 * l - q;
                double hk = h / 360.0;
                double tR = hk + 1.0 / 3.0;
                double tG = hk;
                double tB = hk - 1.0 / 3.0;

                r = HueToRGB(p, q, tR);
                g = HueToRGB(p, q, tG);
                b = HueToRGB(p, q, tB);
            }

            int R = (int)Math.Round(r * 255);
            int G = (int)Math.Round(g * 255);
            int B = (int)Math.Round(b * 255);
            return $"#{R:X2}{G:X2}{B:X2}";
        }

        var random = new Random();

        double Random(double min, double max)
        {
            return random.NextDouble() * (max - min) + min;
        }

        string[] colors = new string[amount];
        double baseHue = random.NextDouble() * 360;
        double step = 360.0 / amount;

        double saturation = Random(0.6, 0.85);
        double lightness = Random(0.35, 0.65);

        for (int i = 0; i < amount; i++)
        {
            double hue = (baseHue + i * step) % 360;
            colors[i] = HSLToHex(hue, saturation, lightness);
        }

        return colors;
    }
}
